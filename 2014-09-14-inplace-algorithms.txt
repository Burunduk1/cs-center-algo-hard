hard = <font color=red>[hard]</font>
sqrtn = &radic;<span style="text-decoration:overline;">&nbsp;n&nbsp;</span>

$ Задачи, решаемые с O(1) дополнительной памяти

# Поточный merge: O(n+m), O(mlogn), O(mlog(n/m+1)) [Hwang,Lin'72]
# Бинарный поиск, сортированнный массив (find, lower\_bound)
# Частичные суммы (сумма на отрезке)
# Дерево Фенвика (сумма на отрезке, элемент можно менять) [Fenwick'94]
# reverse и rotate отрезка за O(n)
# partition (кусок quick sort) [Hoare'61, Algorithm 63: Partition]
# binary heap: insert, deleteMin, decreaseKey [Williams'64]
# sort: heap sort, quick sort, insertion sort, selection sort
# stable merge за O(nlogn), из него stable inplace merge sort за O(nlog^2n) [Pardo'77, Horvarth'78, Wong'81]
# k-heap: deleteMin=k*log_k(n); insert,decreaseKey=log_k(n) [Johnson'75]
# $hard$ minmax heap: deleteMin, deleteMax, insert [Atkinson'86]
## Хранение: odd level = min, even level = max
## GetMin in O(1): root
## GetMax in O(1): max(root.L, root.R)
## SiftDown in O(depth): смотрим на четырех внуков, выбираем из них минимального, swap с ним + разбор случаев
## SiftUp in O(depth): пусть мы min, пусть мы больше отца, тогда swap, а далее идем вверх с шагом, как в обычной Binary Heap
# $hard$ merge in O(n) (все куски алгоритма, которые мы можем, сразу сделаем стабильными) [Huang'88]
## StableMerge(n,m) in O(n + m^2), m = $sqrtn$
## Обычный merge с дополнительной памятью перемешивает значения в доп.памяти, но не портит их
## StableSort($sqrtn$) in O(n)
## Sort кусков in O(n): selection sort
# $hard$ stable merge in O(n), stable sort in O(nlogn)
## Отличие работы [Kim,Kutzner'08] от предыдущих &minus; оптимальное число сравнений O(nlog(n/m+1)) и присваиваний O(n+m)
## Не рекурсивный merge sort
## StableMerge(n,m) in O(n + m) и O(min(n,m)) дополнительной памяти
## StableMerge(n,m) in O(n + m^{3/2}) 
## Общая схема: buffer-extraction, block-rearrangment, local-merges, insert-buffer
## Выделение буффера, состоящего из различных элементов (предположим пока, что различных элементов достаточно)
## Сортировка блоков без их перемещения (помечаем блоки, расставляя различные числа в первых элементах)
## Собственно перемещение блоков (selection sort, возвращаем исходные первые элементы)
# $hard$ Beap: куча + поиск за O($sqrtn$), у каждой вершины два отца! [Munro'80]

$ Задачи, решаемые с O(1) дополнительной памяти на readonly массиве

# Дан массив натуральных чисел. Найти отрезок массива, с суммой ровно S.
# У всех элементов кроме одного есть пара, найти недостающий.
# Найти элемент, который встречается хотя бы n/2 раз (вероятностное решение, честное решение)
# Даны n+1 число от 1 до n, найти любое число, которое встречается больше одного раза

$ Упражнения по теме

# Понять, как работает @link:rotate:http://www.cplusplus.com/reference/algorithm/rotate/?kw=rotate в C++ 
# Даны два массива, a[] и b[], выписать все a[i]+b[j] в отсортированном порядке за O(n^2logn) времени и с O(n) дополнительной памяти
# Найти число инверсий в массиве с O(1) дополнительной памяти
# Можно ли задачу ``минимум на отрезке'' решить за o(n) с использованием всего O(1) дополнительной памяти?
# Как задачу ``минимум на отрезке'' решить за O($sqrtn$), используя O($sqrtn$) дополнительной памяти?

$ Литература

# 1969, Kronrod, доклад в академии наук СССР [inplace merge]
# 1972, Hwang & Lin, A simple algorithm for merging two disjoint linearly ordered sets [merge]
# 1984, Ukkonen & Manilla, A simple linear-time algorithm for in suto merging [inplace merge]
# 1988, Huang & Lagston, Practical in-place merging [inplace merge]
# 2004, Denham, In-place merging algorithms [stable inplace merge]
# 2008, Kim & Kutzner, Ratio based stable in-place merging [stable inplace merge]
# 1975, Johnson, Priority queues with update and finding minimum spanning trees [k-heap]
# 1980, Munro & Suwanda, Implicit data structures for fast search and update [beap]
# 1986, Atkinson et al., Min-Max heaps and generalized priority queues [min-max heap]
# 1994, Fenwick, A new data structure for cumulative frequency tables [fenwick tree]
